# ----------------------------------------------------
# ----- prompt -----------------------------------------
# ----------------------------------------------------

def create_left_prompt [] {
    # Colors (256-color ANSI escape codes)
    let green = (ansi -e '38;5;84m')
    let pink = (ansi -e '38;5;212m')
    let red = (ansi -e '38;5;203m')
    let orange = (ansi -e '38;5;215m')
    let reset = (ansi reset)

    let dir_display = if (do { git rev-parse --is-inside-work-tree } | complete).exit_code == 0 {
        let repo_root = (git rev-parse --show-toplevel | str trim)
        let repo_name = ($repo_root | path basename)
        let rel_path = ($env.PWD | str replace $repo_root "" | str trim --left --char "/")
        if ($rel_path | is-empty) {
            $" ($green)($repo_name)($reset)"
        } else {
            $" ($green)($repo_name)/($rel_path)($reset)"
        }
    } else {
        let home = $env.HOME
        $" ($green)($env.PWD | str replace $home '~')($reset)"
    }

    let git_info = if (do { git rev-parse --is-inside-work-tree } | complete).exit_code == 0 {
        let branch = (do { git branch --show-current } | complete).stdout | str trim
        let branch = if ($branch | is-empty) {
            (git rev-parse --short HEAD | str trim)
        } else {
            $branch
        }

        let dirty = if (git status --porcelain | str trim | is-not-empty) { " *" } else { "" }

        let ahead_behind = do {
            let counts = (do { git rev-list --left-right --count "HEAD...@{u}" } | complete)
            if $counts.exit_code == 0 {
                let parts = ($counts.stdout | str trim | split row "\t")
                let ahead = ($parts | get 0 | into int)
                let behind = ($parts | get 1 | into int)
                let ahead_str = if $ahead > 0 { $" ($red)⇡($ahead)($reset)" } else { "" }
                let behind_str = if $behind > 0 { $" ($red)⇣($behind)($reset)" } else { "" }
                $"($ahead_str)($behind_str)"
            } else {
                ""
            }
        }

        $" ($pink)\u{e0a0} ($branch)($reset)($red)($dirty)($reset)($ahead_behind)"
    } else {
        ""
    }

    let aws_info = if ($env.AWS_VAULT? | default "" | is-not-empty) {
        $" ($orange)\u{f270} ($env.AWS_VAULT)($reset)"
    } else {
        ""
    }

    let ssh_info = if ($env.SSH_CONNECTION? | default "" | is-not-empty) {
        $"($orange)⌁($reset)"
    } else {
        ""
    }

    $"($ssh_info)($dir_display)($git_info)($aws_info)"
}

def create_right_prompt [] { "" }

$env.PROMPT_COMMAND = {|| create_left_prompt }
$env.PROMPT_COMMAND_RIGHT = {|| create_right_prompt }
$env.PROMPT_INDICATOR = {|| $" (if $env.LAST_EXIT_CODE == 0 { ansi -e '38;5;84m' } else { ansi -e '38;5;203m' })❯(ansi reset) " }

# ----------------------------------------------------
# ----- path -----------------------------------------
# ----------------------------------------------------

use std/util "path add"
{{- range .shell.paths }}
{{-   if or (not (hasKey . "os")) (eq .os $.chezmoi.os) }}
{{-     if and (hasKey . "relative") .relative }}
path add ($env.HOME | path join "{{ .path }}")
{{-     else }}
path add "{{ .path }}"
{{-     end }}
{{-   end }}
{{- end }}

# ----------------------------------------------------
# ----- env -----------------------------------------
# ----------------------------------------------------

$env.config.show_banner = false
$env.SHELL = $env.HOME | path join ".local/bin/nu"

{{ range $name, $val := .shell.env -}}
{{-   if kindIs "map" $val }}
$env.{{ $name }} = if (which {{ $val.check }} | is-empty) { "{{ $val.fallback }}" } else { "{{ $val.value }}" }
{{-   else if hasPrefix "." $val }}
$env.{{ $name }} = $env.HOME | path join "{{ $val }}"
{{-   else }}
$env.{{ $name }} = "{{ $val }}"
{{-   end }}
{{ end }}
$env.config.buffer_editor = $env.EDITOR

# ----------------------------------------------------
# ----- funcs -----------------------------------------
# ----------------------------------------------------

# forces devpod to use zsh internally to avoid parsing errors
# NOTE: nushell-only, no need to sync to zsh
def --wrapped devpod [...rest] {
	with-env { SHELL: 'zsh' } {
		^devpod ...$rest
	}
}

{{ range $name, $func := .shell.functions -}}
# {{ $func.description }}
def {{ $name }} [] {
  {{ $func.nu }}
}

{{ end -}}
# worktrunk (wt) shell integration for nushell
# Intercepts -x/--execute to run commands with proper nushell TTY
def --env --wrapped wt [...rest] {
  let x_matches = ($rest | enumerate | where {|it| $it.item == "-x" or $it.item == "--execute"})
  let x_idx = if ($x_matches | is-empty) { null } else { $x_matches | first | get index }
  let execute_cmd = if $x_idx != null {
    if ($x_idx + 1) < ($rest | length) { $rest | get ($x_idx + 1) } else { null }
  } else {
    null
  }
  let wt_args = if $execute_cmd != null {
    $rest | enumerate | where {|it| $it.index != $x_idx and $it.index != ($x_idx + 1)} | get item
  } else {
    $rest
  }
  let original_dir = $env.PWD

  let directive_file = (mktemp)
  try {
    with-env { WORKTRUNK_DIRECTIVE_FILE: $directive_file } {
      ^wt ...$wt_args
    }
  } catch {
    rm -f $directive_file
    return
  }

  let directives = if ($directive_file | path exists) {
    open $directive_file --raw | str trim
  } else {
    ""
  }
  rm -f $directive_file

  if ($directives | is-not-empty) {
    let parsed = ($directives | parse "cd '{path}'")
    if ($parsed | is-not-empty) {
      cd ($parsed | get path | first)
    }
  }

  if $execute_cmd != null {
    try { nu -c $execute_cmd }
    cd $original_dir
  }
}


# ----------------------------------------------------
# ----- alias -----------------------------------------
# ----------------------------------------------------

{{ range $name, $cmd := .shell.aliases -}}
alias {{ $name }} = {{ $cmd }}
{{ end }}

{{- if eq .chezmoi.os "darwin" }}

alias typora = ^open -a Typora
{{- end }}

# ----------------------------------------------------
# ----- fnm (node version manager) --------------------
# ----------------------------------------------------

if not (which fnm | is-empty) {
    let fnm_env = (^fnm env --json | from json)
    $fnm_env | load-env
    $env.PATH = ($env.PATH | prepend ($fnm_env.FNM_MULTISHELL_PATH | path join "bin"))
}

# ----------------------------------------------------
# ----- mise (tool version manager) -------------------
# ----------------------------------------------------

$env.PATH = ($env.PATH | split row (char esep) | prepend ($env.HOME | path join ".local/share/mise/shims"))
