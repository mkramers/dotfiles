# ----------------------------------------------------
# ----- path -----------------------------------------
# ----------------------------------------------------

use std/util "path add"
{{- range .shell.paths }}
{{-   if or (not (hasKey . "os")) (eq .os $.chezmoi.os) }}
{{-     if and (hasKey . "relative") .relative }}
path add ($env.HOME | path join "{{ .path }}")
{{-     else }}
path add "{{ .path }}"
{{-     end }}
{{-   end }}
{{- end }}

# ----------------------------------------------------
# ----- env -----------------------------------------
# ----------------------------------------------------

$env.config.show_banner = false
$env.SHELL = $env.HOME | path join ".local/bin/nu"

{{ range $name, $val := .shell.env -}}
{{-   if kindIs "map" $val }}
$env.{{ $name }} = if (which {{ $val.check }} | is-empty) { "{{ $val.fallback }}" } else { "{{ $val.value }}" }
{{-   else if hasPrefix "." $val }}
$env.{{ $name }} = $env.HOME | path join "{{ $val }}"
{{-   else }}
$env.{{ $name }} = "{{ $val }}"
{{-   end }}
{{ end }}
$env.config.buffer_editor = $env.EDITOR

# ----------------------------------------------------
# ----- funcs -----------------------------------------
# ----------------------------------------------------

# forces devpod to use zsh internally to avoid parsing errors
# NOTE: nushell-only, no need to sync to zsh
def --wrapped devpod [...rest] {
	with-env { SHELL: 'zsh' } {
		^devpod ...$rest
	}
}

{{ range $name, $func := .shell.functions -}}
# {{ $func.description }}
def {{ $name }} [] {
  {{ $func.nu }}
}

{{ end -}}
# worktrunk (wt) shell integration for nushell
# Intercepts -x/--execute to run commands with proper nushell TTY
def --env --wrapped wt [...rest] {
  let x_matches = ($rest | enumerate | where {|it| $it.item == "-x" or $it.item == "--execute"})
  let x_idx = if ($x_matches | is-empty) { null } else { $x_matches | first | get index }
  let execute_cmd = if $x_idx != null {
    if ($x_idx + 1) < ($rest | length) { $rest | get ($x_idx + 1) } else { null }
  } else {
    null
  }
  let wt_args = if $execute_cmd != null {
    $rest | enumerate | where {|it| $it.index != $x_idx and $it.index != ($x_idx + 1)} | get item
  } else {
    $rest
  }
  let original_dir = $env.PWD

  let directive_file = (mktemp)
  try {
    with-env { WORKTRUNK_DIRECTIVE_FILE: $directive_file } {
      ^wt ...$wt_args
    }
  } catch {
    rm -f $directive_file
    return
  }

  let directives = if ($directive_file | path exists) {
    open $directive_file --raw | str trim
  } else {
    ""
  }
  rm -f $directive_file

  if ($directives | is-not-empty) {
    let parsed = ($directives | parse "cd '{path}'")
    if ($parsed | is-not-empty) {
      cd ($parsed | get path | first)
    }
  }

  if $execute_cmd != null {
    try { nu -c $execute_cmd }
    cd $original_dir
  }
}

# create worktree and open claude in it
def --env --wrapped wtc [...rest] {
  wt switch --create ...$rest -x claude
}

# ----------------------------------------------------
# ----- alias -----------------------------------------
# ----------------------------------------------------

{{ range $name, $cmd := .shell.aliases -}}
alias {{ $name }} = {{ $cmd }}
{{ end }}

# allows us to edit the config.nu chezmoi source file instead of the real one
def confignu [] {
  ^$env.EDITOR (chezmoi source-path | decode utf-8 | str trim | path join "dot_config/nushell/config.nu.tmpl")
}

# ----------------------------------------------------
# ----- mise (tool version manager) -------------------
# ----------------------------------------------------

$env.PATH = ($env.PATH | split row (char esep) | prepend ($env.HOME | path join ".local/share/mise/shims"))
