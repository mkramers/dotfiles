# ----------------------------------------------------
# ----- prompt ----------------------------------------
# ----------------------------------------------------

def git_prompt [] {
    let branch = (do { ^git branch --show-current } | complete)
    if $branch.exit_code != 0 { return "" }
    let name = ($branch.stdout | str trim)
    if ($name | is-empty) { return "" }

    mut arrows = ""
    let upstream = (do { ^git rev-list --left-right --count 'HEAD...@{upstream}' } | complete)
    if $upstream.exit_code == 0 {
        let counts = ($upstream.stdout | str trim | split row "\t")
        if ($counts | get 0 | into int) > 0 { $arrows = $"($arrows)↑" }
        if ($counts | get 1 | into int) > 0 { $arrows = $"($arrows)↓" }
    }

    $"(ansi magenta)\(($name)($arrows)\)(ansi reset) "
}

$env.PROMPT_COMMAND = {||
    let dir = ($env.PWD | str replace $env.HOME '~')
    let git = (git_prompt)
    if ($git | is-empty) {
        $"(ansi -e '38;5;141')($dir)(ansi reset) ❯ "
    } else {
        $"(ansi -e '38;5;141')($dir)(ansi reset) ($git)❯ "
    }
}
$env.PROMPT_INDICATOR = ""

# ----------------------------------------------------
# ----- path -----------------------------------------
# ----------------------------------------------------

use std/util "path add"
{{- range .shell.paths }}
{{-   if or (not (hasKey . "os")) (eq .os $.chezmoi.os) }}
{{-     if and (hasKey . "relative") .relative }}
path add ($env.HOME | path join "{{ .path }}")
{{-     else }}
path add "{{ .path }}"
{{-     end }}
{{-   end }}
{{- end }}

# ----------------------------------------------------
# ----- env -----------------------------------------
# ----------------------------------------------------

$env.config.show_banner = false
$env.SHELL = $env.HOME | path join ".local/bin/nu"

{{ range $name, $val := .shell.env -}}
{{-   if kindIs "map" $val }}
$env.{{ $name }} = if (which {{ $val.check }} | is-empty) { "{{ $val.fallback }}" } else { "{{ $val.value }}" }
{{-   else if hasPrefix "." $val }}
$env.{{ $name }} = $env.HOME | path join "{{ $val }}"
{{-   else }}
$env.{{ $name }} = "{{ $val }}"
{{-   end }}
{{ end }}
$env.config.buffer_editor = $env.EDITOR

# ----------------------------------------------------
# ----- funcs -----------------------------------------
# ----------------------------------------------------

# forces devpod to use zsh internally to avoid parsing errors
# NOTE: nushell-only, no need to sync to zsh
def --wrapped devpod [...rest] {
	with-env { SHELL: 'zsh' } {
		^devpod ...$rest
	}
}

{{ range $name, $func := .shell.functions -}}
# {{ $func.description }}
def {{ $name }} [] {
  {{ $func.nu }}
}

{{ end -}}
# worktrunk (wt) shell integration for nushell
# Intercepts -x/--execute to run commands with proper nushell TTY
def --env --wrapped wt [...rest] {
  let x_matches = ($rest | enumerate | where {|it| $it.item == "-x" or $it.item == "--execute"})
  let x_idx = if ($x_matches | is-empty) { null } else { $x_matches | first | get index }
  let execute_cmd = if $x_idx != null {
    if ($x_idx + 1) < ($rest | length) { $rest | get ($x_idx + 1) } else { null }
  } else {
    null
  }
  let wt_args = if $execute_cmd != null {
    $rest | enumerate | where {|it| $it.index != $x_idx and $it.index != ($x_idx + 1)} | get item
  } else {
    $rest
  }
  let original_dir = $env.PWD

  let directive_file = (mktemp)
  try {
    with-env { WORKTRUNK_DIRECTIVE_FILE: $directive_file } {
      ^wt ...$wt_args
    }
  } catch {
    rm -f $directive_file
    return
  }

  let directives = if ($directive_file | path exists) {
    open $directive_file --raw | str trim
  } else {
    ""
  }
  rm -f $directive_file

  if ($directives | is-not-empty) {
    let parsed = ($directives | parse "cd '{path}'")
    if ($parsed | is-not-empty) {
      cd ($parsed | get path | first)
    }
  }

  if $execute_cmd != null {
    try { nu -c $execute_cmd }
    cd $original_dir
  }
}

# create worktree and open claude in it
def --env --wrapped wtc [...rest] {
  wt switch --create ...$rest -x claude
}

# ----------------------------------------------------
# ----- alias -----------------------------------------
# ----------------------------------------------------

{{ range $name, $cmd := .shell.aliases -}}
alias {{ $name }} = {{ $cmd }}
{{ end }}

{{- if eq .chezmoi.os "darwin" }}

alias typora = ^open -a Typora
{{- end }}

# ----------------------------------------------------
# ----- mise (tool version manager) -------------------
# ----------------------------------------------------

$env.PATH = ($env.PATH | split row (char esep) | prepend ($env.HOME | path join ".local/share/mise/shims"))
